æœ¬æ–‡æ¡£ä¸ºå®éªŒæŒ‡å¯¼ä¹¦çš„è¡¥å……è¯´æ˜ï¼Œè¯·åŒå­¦ä»¬ä¼˜å…ˆä»”ç»†é˜…è¯»å®éªŒæŒ‡å¯¼ä¹¦

# å®éªŒäºŒ

å°†å®éªŒ1çš„ASTæŠ½è±¡è¯­æ³•æ ‘è½¬æ¢æˆIRï¼ˆä¸­é—´è¡¨ç¤ºï¼‰

![lab2.drawio](./../assets/lab2.drawio.svg)

## æ•°æ®ç»“æ„

### IR

å®éªŒå¯¹ SysY è¯­è¨€è®¾è®¡äº†ç»Ÿä¸€çš„ IR æ¡†æ¶ï¼Œæ‰€æœ‰ IR é‡‡ç”¨å››å…ƒçš„å½¢å¼ï¼Œå³ï¼š

`opcode`, `des`, `operand1`,  `operand2`

æ¯ä¸ªIRè¡¨ç¤ºå¯ä»¥åœ¨å®éªŒæŒ‡å¯¼ä¹¦ä¸­æŸ¥åˆ°ã€‚ä¸¾ä¾‹æ¥è¯´ï¼Œä½ éœ€è¦å°†å½¢å¦‚

```cpp
int a = 8;
```

è½¬æ¢ä¸º

```assembly
def a, 8
```

è¿™ç§IRè¡¨ç¤ºã€‚

### å…¥å£å‡½æ•°ä¸åŸºæœ¬æ•°æ®ç»“æ„

åœ¨ `main.cpp` æ–‡ä»¶ä¸­ï¼Œæœ‰

```cpp
frontend::Analyzer analyzer;
auto program = analyzer.get_ir_program(node);
```

æˆ‘ä»¬éœ€è¦å®Œæˆè¿™ä¸ª `get_ir_program`

å‡½æ•°å…¥å£åœ¨è¿™é‡Œï¼Œ`src/front/semantic.cpp`

```cpp
ir::Program frontend::Analyzer::get_ir_program(CompUnit* root)
```

ä½ å¯ä»¥å‘ç°è¿™ä¸ªå‡½æ•°çš„è¾“å…¥ï¼Œæ˜¯å®éªŒä¸€åˆ†æå¾—åˆ°çš„æ ¹èŠ‚ç‚¹ `CompUnit`çš„æŒ‡é’ˆã€‚ è®©ä½ è¾“å‡ºçš„å°±æ˜¯ä¸€ä¸ª `ir::Program`.

æ¥çœ‹ä¸€ä¸‹ `ir::Program` çš„æ•°æ®ç»“æ„

```cpp
namespace ir
{
    // ...
    struct Program {
        std::vector<Function> functions;
        std::vector<GlobalVal> globalVal;
        Program();
        void addFunction(const Function& proc);
        std::string draw();
    };

}
```

æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦å¾—çŸ¥ `Program` ä¸­çš„ `functions` å’Œ `globalVal` ä¸¤ä¸ªå˜é‡ã€‚

å½“æˆ‘ä»¬æŠŠä¸€ä¸ªç¨‹åºçš„ functions å’Œ globalVal éƒ½è§£æå®Œæˆçš„æ—¶å€™ï¼Œå®éªŒä¹Ÿå°±åšå®Œäº†ï¼ğŸ˜Š

å¥½è€¶ï¼ä¸€å®šå¾ˆç®€å•å§ï¼ŸğŸ¤¡

### Function

è¿™ä¸ª Function çš„æ•°æ®ç»“æ„åˆ°åº•æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿè¯·æŸ¥çœ‹`include/ir/ir_function.h`ï¼š

```cpp
struct Function {
    std::string name;
    ir::Type returnType;
    std::vector<Operand> ParameterList;
    std::vector<Instruction*> InstVec;
    Function();
    Function(const std::string&, const ir::Type&);
    Function(const std::string&, const std::vector<Operand>&, const ir::Type&);
    void addInst(Instruction* inst);
    std::string draw();
};
```

å°±è·Ÿæˆ‘ä»¬çš„ç¨‹åºé‡Œé¢çš„å‡½æ•°ï¼ˆmainå‡½æ•°ï¼Œaddå‡½æ•°ç­‰ç­‰ï¼‰ä¸€æ ·ï¼Œé€šè¿‡è¿™äº›å‘½åå¯ä»¥è¯»å‡ºæ¥ä¸€ä¸ª function å¿…é¡»è¦æœ‰

- `name`: å‡½æ•°å
- `returnType`: è¿”å›ç±»å‹ï¼Œæ•°æ®ç»“æ„æ˜¯ä¸€ä¸ªTypeã€‚
- `ParameterList`: å‚æ•°åˆ—è¡¨ï¼Œæ•°æ®ç»“æ„æ˜¯ä¸€ä¸ª **Operand** çš„æ•°ç»„ã€‚
- `InstVec`: æŒ‡ä»¤çš„åˆ—è¡¨ï¼Œæ•°æ®ç»“æ„æ˜¯ä¸€ä¸ª **Instruction**æŒ‡é’ˆçš„æ•°ç»„ã€‚

ä¸çŸ¥é“ä½ ä»¬è¿˜è®°ä¸è®°å¾—ï¼Œåœ¨å®éªŒä¸€ä¸­æœ‰èŠ‚ç‚¹ç±»å‹ä¸“é—¨å°±æ˜¯ç”¨æ¥è§£æåå­—ã€è¿”å›ç±»å‹çš„ï¼Œæ˜¯ä»€ä¹ˆå‘¢ï¼Œå¥½éš¾çŒœå•Šï¼Ÿ

> FuncDef -> FuncType Ident '(' [FuncFParams] ')' Block

### Operand

é¡¾åæ€ä¹‰ï¼Œ**æ“ä½œæ•°**ã€‚

è¿˜è®°å¾—åˆšæ‰æˆ‘ä»¬IRçš„å…·ä½“è¡¨ç¤ºä¸ºä¸€ä¸ªå››å…ƒç»„å—ï¼Ÿ`opcode`, `des`, `operand1`,  `operand2`

opcodeå¾ˆå¥½ç†è§£ï¼Œæ— éå°±æ˜¯ä¸€ä¸ªæ“ä½œçš„æšä¸¾ç±»å‹ï¼Œæ¯”å¦‚æœ‰add, store, ...

è¿™é‡Œé¢å…¶ä½™ä¸‰ä¸ªï¼Œop1ã€op2å’Œdeséƒ½æ˜¯æ“ä½œæ•°ã€‚

```cpp
namespace ir {

enum class Type {
    Int,
    Float,
    IntLiteral,
    FloatLiteral,
    IntPtr,
    FloatPtr,
    null
};

std::string toString(Type t);

struct Operand {
    std::string name;
    Type type;
    Operand(std::string = "null", Type = Type::null);
};

}
```

ä¸€ä¸ª Operand æœ‰å®ƒçš„ç±»å‹å’Œå®ƒçš„åå­—

ç±»å‹typeï¼š

- Intï¼šæ•´å‹ã€‚æ¯”å¦‚ `int x` è¿™é‡Œé¢ x å°±æ˜¯ä¸€ä¸ªæ•´å‹ã€‚
- Floatï¼šæµ®ç‚¹å‹ã€‚
- IntLiteralï¼šæ•´å‹å­—é¢é‡ã€‚æ¯”å¦‚`1`, `2`, `1024`è¿™ç§ã€‚
- FloatLiteralï¼šæµ®ç‚¹å‹å­—é¢é‡ã€‚
- IntPtrï¼šæ•´å‹æŒ‡é’ˆï¼Œæ•°ç»„éœ€è¦ç”¨ã€‚
- FloatPtrï¼šæµ®ç‚¹å‹æŒ‡é’ˆã€‚

æ¯”å¦‚ `int x = 2;` è¿™æ¡æŒ‡ä»¤ï¼Œ`x` æ˜¯ä¸€ä¸ª Int çš„æ“ä½œæ•°ï¼Œ`1` æ˜¯ä¸€ä¸ª IntLiteral çš„æ“ä½œæ•°ã€‚

### Instruction

æ€ä¹ˆå®šä¹‰ä¸€æ¡æŒ‡ä»¤ï¼Ÿåœ¨`ir_instruction.h`ä¸­æœ‰ï¼š

```cpp
struct Instruction {
    Operand op1;  // æ“ä½œæ•°1
    Operand op2;  // æ“ä½œæ•°2
    Operand des;  // ç»“æœ
    Operator op;  // æ“ä½œ
    Instruction();
    Instruction(const Operand& op1, const Operand& op2, const Operand& des, const Operator& op);
    virtual std::string draw() const;
};
```

å°±è·Ÿåˆšæ‰çš„å››å…ƒç»„ä¸€æ ·ï¼Œæˆ‘ä»¬éœ€è¦ç…§ç€è¿™ä¸ªæ¥ç”ŸæˆæŒ‡ä»¤ã€‚

æ¯”å¦‚ï¼š

```cpp
int x = a + b;  // å‡è®¾a, b éƒ½æ˜¯intç±»å‹
```

è¿™æ¡æŒ‡ä»¤ï¼Œä½ å°±éœ€è¦æ„é€ ç±»ä¼¼è¿™æ ·çš„Instruction

```cpp
auto inst = ir::Instruction{Operand{"a", Type::Int}, Operand{"b", Type::Int}, Operand{"x", Type::Int}, Operator::add}
```

å›é¡¾ä¸€ä¸‹ï¼Œä¸€ä¸ªFunctionæœ‰å®ƒçš„nameï¼ŒreturnTypeï¼Œå‚æ•°åˆ—è¡¨å’Œä¸€å †æŒ‡ä»¤ã€‚è€Œè¿™äº›æ•°æ®æˆ‘ä»¬ç°åœ¨éƒ½å¯ä»¥åœ¨æŸäº›èŠ‚ç‚¹è·å¾—ï¼Œé€šè¿‡è¿™äº›èŠ‚ç‚¹æ¥å®Œæˆè¿™ä¸ªfunctionï¼Œæˆ‘ä»¬çš„ä»»åŠ¡å°±å®Œæˆäº†ã€‚

### globalVal

å…¨å±€å˜é‡ï¼Œå®šä¹‰ä¸ºè¿™æ ·ï¼š

```cpp
struct GlobalVal
    {
        ir::Operand val;
        int maxlen = 0;     //ä¸ºæ•°ç»„é•¿åº¦è®¾è®¡
        GlobalVal(ir::Operand va);
        GlobalVal(ir::Operand va, int len);
    };
```

æœ‰ä¸¤ä¸ªæ•°æ®ï¼Œä¸€ä¸ªæ“ä½œæ•°ï¼Œå’Œä¸€ä¸ªmaxlenï¼Œè®°å½•æ•°ç»„é•¿åº¦ï¼Œå½“ä¸æ˜¯æ•°ç»„æ—¶å€¼ä¸º0.

å…¨å±€å˜é‡ï¼Œé¡¾åæ€ä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å…¨å±€ä¸­è®¿é—®åˆ°è¿™äº›æ“ä½œæ•°ã€‚ä¸ä¹‹ä¸€ä¸ªç›¸å…³çš„æ¦‚å¿µæ˜¯ä½œç”¨åŸŸã€‚

### scopeï¼ˆä½œç”¨åŸŸï¼‰

å›é¡¾ä¸€ä¸‹ç¨‹åºè®¾è®¡åŸºç¡€ï¼Œå‡è®¾æœ‰è¿™ä¹ˆä¸€æ®µç¨‹åº

```cpp
int main() {
    int a = 1;
    if (true) {
        int a = 3;
        while (true) {
            if (a == 5) {
                break;
            }
            a++;
        }
    }
    cout << a << endl;
    return 0;
}
```

è¿™é‡Œæ‰“å°çš„å€¼ä¼šæ˜¯å¤šå°‘ï¼Ÿè¿è¡Œç¨‹åºè·‘å‡ºæ¥æ˜¯ `1`ï¼Œè¿™æ˜¯å› ä¸ºä½œç”¨åŸŸçš„ç¼˜æ•…ã€‚

åœ¨è¿›å…¥ä¸€ä¸ªblockï¼ˆå¤§æ‹¬å·æ‹¬èµ·æ¥çš„åŒºåŸŸï¼‰ï¼Œå˜é‡çš„ä½œç”¨åŸŸä¼šå‘ç”Ÿå˜æ›´ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬è®¨è®ºå˜é‡çš„ä¸Šä¸‹æ–‡å‘ç”Ÿäº†åˆ‡æ¢ã€‚

æ‰§è¡Œ `int a = 3` æ—¶ï¼Œå·²ç»æ˜¯åœ¨ä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸå‘ç”Ÿçš„äº‹æƒ…äº†ï¼Œç›´åˆ°é‡åˆ°å¤§æ‹¬å·çš„æœ«å°¾é€€å‡ºblockï¼Œæ‰é€€å›åˆ°äº†åŸæ¥çš„ä½œç”¨åŸŸã€‚

ä»”ç»†æƒ³æƒ³ï¼Œè¿™è·Ÿæˆ‘ä»¬å­¦è¿‡çš„ä¸€ä¸ªæ•°æ®ç±»å‹å¾ˆç›¸ä¼¼ï¼Œå½“é‡åˆ°ä¸€ä¸ª `{` è¿›å…¥æ–°çš„ä½œç”¨åŸŸï¼Œè®¿é—®å˜é‡æ—¶å»è·å–è¿™ä¸ªå˜é‡å­˜åœ¨çš„æœ€æ–°ä½œç”¨åŸŸã€‚

æ²¡é”™ï¼Œè¿™æ˜¯ä¸€ä¸ª**æ ˆ**ã€‚

åœ¨ç¨‹åºä¸­ï¼Œæœ‰ä¸€ä¸ªæ•°æ®ç»“æ„å«**ç¬¦å·è¡¨**ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°ç›¸å…³çš„æ•°æ®å’Œå‡½æ•°ï¼š

```cpp
// definition of symbol table
struct SymbolTable {
    vector<ScopeInfo> scope_stack;
    map<std::string, ir::Function*> functions;
    int scope_cnt;

    void add_scope();
    void exit_scope();

    string get_scoped_name(string id) const;
    ir::Operand get_operand(string id) const;
    STE get_ste(string id) const;
    void add_ste(const string& id, STE ste);
};
```

è¿™é‡Œçš„scope_stackå°±æ˜¯ä¸€ä¸ªä½œç”¨åŸŸçš„æ ˆã€‚

ç¬¦å·è¡¨æ˜¯ä¸€ä¸ªåœ¨å®éªŒäºŒä¸­é‡è¦çš„æ•°æ®ç»“æ„ï¼Œè¯·æ ¹æ®ä»¥ä¸Šå†…å®¹è‡ªè¡Œç ”ç©¶ã€‚

## ç®—æ³•

### è¯¥ä»å“ªé‡Œå…¥æ‰‹

æˆ‘ä»¬æœ€ç»ˆè¦å†™çš„å‡½æ•°ï¼š

```cpp
ir::Program frontend::Analyzer::get_ir_program(CompUnit* root){
    ir::Program program;
    // do something
    // ...
    reutrn program; 
}
```

ä¸å¦¨æˆ‘ä»¬å…ˆæ¥è¯•ä¸€ä¸‹è¿™ä¸ªç¨‹åº

```cpp
int main(){
    return 3;
}
```

å®ƒçš„ASTåº”è¯¥æ˜¯

```json
{
   "name" : "CompUnit",
   "subtree" : [
      {
         "name" : "FuncDef",
         "subtree" : [
            {
               "name" : "FuncType",
               "subtree" : [
//...
```

ä¸€å¼€å§‹ï¼Œä¼ è¿›æ¥çš„æ—¶å€™ä¸€ä¸ªCompUnit*ï¼Œå®ƒçš„æ–‡æ³•æ˜¯è¿™æ ·çš„

```cpp
// CompUnit -> (Decl | FuncDef) [CompUnit]
```

æˆ‘ä»¬è¦å»åˆ†æè¿™ä¸ªèŠ‚ç‚¹ï¼Œå°±å’Œå®éªŒä¸€ä¸€æ ·ï¼Œ**æ•´ä¸ªè¿‡ç¨‹æ˜¯é€’å½’çš„ã€‚**

æˆ‘ä»¬å®šä¹‰ä¸€ä¸ª `analysisCompUnit` å‡½æ•°ï¼š

```cpp
// CompUnit -> (Decl | FuncDef) [CompUnit]
void frontend::Analyzer::analysisCompUnit(CompUnit* root,
                                          ir::Program& program) {
    if (Decl* node = dynamic_cast<Decl*>(root->children[0])) { // Decl
        vector<Instruction*> decl_insts;
        analysisDecl(node, decl_insts);
        for (auto& inst : decl_insts) {
            symbol_table.functions["global"]->addInst(inst);
        }
    } else if (FuncDef* node = dynamic_cast<FuncDef*>(root->children[0])) {
        Function* new_func = new Function();
        analysisFuncDef(node, new_func);
        program.addFunction(*new_func);
    } else {
        assert(0 && "Unknown node type");
    }
    if (root->children.size() == 2) {
        GET_CHILD_PTR(child_comp, CompUnit, 1);
        analysisCompUnit(child_comp, program);
    }
}
```

`root->children[0]` åªæœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€ä¸ªæ˜¯ `Decl` èŠ‚ç‚¹ï¼Œä¸€ä¸ªæ˜¯ `FuncDef`èŠ‚ç‚¹ã€‚æˆ‘ä»¬è¯¥æ€ä¹ˆåšåˆ¤æ–­ï¼Œ dynamic_cast<Decl*>(root->children[0]) è¿™ç§æ–¹å¼ï¼Œå…¶å«ä¹‰æ˜¯ï¼Œå°† `root->children[0]` åŠ¨æ€è½¬æ¢ä¸º `Decl*` çš„ç±»å‹ï¼Œå¦‚æœä¸å¯ä»¥è½¬æ¢ï¼Œ`node`åˆ™æ˜¯ä¸€ä¸ª`nullptr`ï¼Œ`nullptr` çš„boolå€¼ä¸º`falseã€‚æ‰€ä»¥ç­‰ä»·äºåšäº†ä¸€ä¸ªç±»å‹åˆ¤æ–­ã€‚

å›åˆ°ç¨‹åºä¸­ï¼Œæˆ‘ä»¬çš„ç¨‹åºåœ¨è¿™ä¸€ä¸ªèŠ‚ç‚¹ä¼šå¾—åˆ°å…¶ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹çš„ç±»å‹æ˜¯`FuncDef`ï¼Œäºæ˜¯åœ¨è¿™é‡Œè¿›å…¥ç¬¬äºŒä¸ªé€»è¾‘åˆ†æ”¯ã€‚æ­¤æ—¶æˆ‘ä»¬è¦ä¸»åŠ¨new ä¸€ä¸ªæ–°çš„functionï¼ˆå› ä¸ºå·²ç»è¦å‡½æ•°å®šä¹‰äº†ï¼‰ï¼Œæˆ‘ä»¬ç»§ç»­å†™ `analysisFuncDef` å‡½æ•°ã€‚

```cpp
// FuncDef -> FuncType Ident '(' [FuncFParams] ')' Block
void frontend::Analyzer::analysisFuncDef(frontend::FuncDef* root,
                                         Function* func) {
    symbol_table.add_scope();
    GET_CHILD_PTR(functype, FuncType, 0);
    GET_CHILD_PTR(ident, Term, 1);
    GET_IDENFR_NAME(id, ident);
    // ...
    symbol_table.exit_scope();
}
```

åœ¨ `semantic.cpp` ä¸­ï¼Œå†™å¥½äº†å‡ ä¸ªå®å¯ä»¥è°ƒç”¨ï¼Œæ¯”å¦‚ï¼š

```cpp
#define GET_CHILD_PTR(node, type, index)                                       \
    auto node = static_cast<type*>(root->children[index])
```

GET_CHILD_PTR(functype, FuncType, 0); å…¶å«ä¹‰æ˜¯ï¼Œæˆ‘éœ€è¦æŠŠç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹èµ‹å€¼åˆ° `functype` è¿™ä¸ªå˜é‡é‡Œï¼Œå…¶ç±»å‹æ˜¯FuncType

æ­¤æ—¶ `functype` å°±æ˜¯ä¸€ä¸ªèŠ‚ç‚¹æŒ‡é’ˆäº†ã€‚

è¿˜æœ‰ä¸€ä¸ªå®æ˜¯ï¼š

```cpp
#define GET_IDENFR_NAME(_id, _term)                                            \
    std::string _id;                                                           \
    _id = _term->token.value
```

GET_IDENFR_NAME(id, ident); å…¶å«ä¹‰æ˜¯ï¼Œæˆ‘éœ€è¦æŠŠidentï¼ˆæ˜¯ä¸€ä¸ª`Term*`ï¼‰çš„å€¼æ”¾åœ¨idè¿™é‡Œï¼Œidæ˜¯ä¸€ä¸ªstringç±»å‹ã€‚

ä¹Ÿå°±æ˜¯è¯´ï¼Œé€šè¿‡åˆ†æGET_IDENFR_NAMEï¼Œæˆ‘ä»¬è·å¾—äº†idå…¶å€¼ä¸º`main`

ä½ è¦å†™æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„analyzeå‡½æ•°ï¼Œå½¢å¦‚ï¼š

```cpp
// analysis functions
void analysisCompUnit(CompUnit*, ir::Program&);
void analysisDecl(Decl*, vector<ir::Instruction*>&);
void analysisConstDecl(ConstDecl*, vector<ir::Instruction*>&);
void analysisVarDecl(VarDecl*, vector<ir::Instruction*>&);
void analysisConstDef(ConstDef*, ir::Type, vector<ir::Instruction*>&);
void analysisVarDef(VarDef*, ir::Type, vector<ir::Instruction*>&);
void analysisFuncDef(FuncDef*, ir::Function*);
void analysisFuncFParams(FuncFParams*, ir::Function*);
void analysisFuncFParam(FuncFParam*, ir::Function*);
void analysisBlock(Block*, vector<ir::Instruction*>&, bool);
void analysisBlockItem(BlockItem*, vector<ir::Instruction*>&);
void analysisStmt(Stmt*, vector<ir::Instruction*>&);

void analysisCond(Cond*, vector<ir::Instruction*>&);

Type analysisBType(BType*);
Type analysisFuncType(FuncType*);

void
    analysisConstInitVal(ConstInitVal*, ir::Type, vector<ir::Instruction*>&);
void analysisInitVal(InitVal*, ir::Type, vector<ir::Instruction*>&);
void analysisConstExp(ConstExp*, vector<ir::Instruction*>&);
void analysisAddExp(AddExp*, vector<ir::Instruction*>&);
void analysisMulExp(MulExp*, vector<ir::Instruction*>&);
void analysisUnaryExp(UnaryExp*, vector<ir::Instruction*>&);
void
    analysisFuncRParams(FuncRParams*, vector<ir::Instruction*>&, ir::Function*);
void analysisPrimaryExp(PrimaryExp*, vector<ir::Instruction*>&);
void analysisExp(Exp*, vector<ir::Instruction*>&);
void analysisLVal(LVal*, vector<ir::Instruction*>&, bool);
void analysisNumber(Number*);

void analysisLOrExp(LOrExp*, vector<ir::Instruction*>&);
void analysisLAndExp(LAndExp*, vector<ir::Instruction*>&);
void analysisEqExp(EqExp*, vector<ir::Instruction*>&);
void analysisRelExp(RelExp*, vector<ir::Instruction*>&);
```

å…¶ä¸­æœ‰äº›æ¥å£å‚æ•°æ˜¯æˆ‘çš„ç¨‹åºéœ€è¦ç”¨çš„ï¼Œå¯ä»¥æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚ä» `analysisCompUnit` å‡½æ•°**è‡ªé¡¶å‘ä¸‹**è°ƒç”¨ï¼Œè¿‡ç¨‹ä¸­ä¼šä¾æ¬¡åˆ†æåˆ°functionï¼Œinstç­‰ç­‰ï¼ŒæŠŠè¿™äº›åŠ å…¥åˆ°programä¸­ï¼Œæœ€åè¿”å›programå³å¯ã€‚

### ä¸€äº›å¤„ç†

è¿™äº›å¤„ç†éå¿…è¦ï¼Œä¹Ÿå¯ä»¥æœ‰è‡ªå·±çš„å®ç°æ–¹å¼ã€‚

### å‡½æ•°ä½œç”¨åŸŸ

æ­£å¦‚åˆšæ‰æ‰€è¯´ï¼Œå½“è¿›å…¥åˆ†æFuncDefèŠ‚ç‚¹æ—¶ï¼Œå‡½æ•°å°±è¿›å…¥äº†ä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸï¼Œè¿™æ˜¯å› ä¸ºå‡½æ•°å‚æ•°ä¹Ÿåœ¨è¿™ä¸ªä½œç”¨åŸŸå½“ä¸­

```cpp
int f(int a, int b){
    int c = 1;
    return 100;
}
```

å½“æˆ‘è¿›å…¥ä¸€ä¸ªå‡½æ•°å®šä¹‰çš„å¤§æ‹¬å·æ—¶ï¼Œä¾¿ä¸å†è¿›å…¥ä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸï¼Œæ­¤æ—¶ a, b, c åœ¨ä¸€ä¸ªä½œç”¨åŸŸé‡Œã€‚

```cpp
{
    {"a", <ä¼ è¿‡æ¥çš„å€¼>},
    {"b", <ä¼ è¿‡æ¥çš„å€¼>},
    {"c", 100},
}
```

æ‰€ä»¥è¿™é‡Œçš„

```cpp
void analysisBlock(Block*, vector<ir::Instruction*>&, bool);
```

å¤šäº†ä¸€ä¸ªboolç±»å‹ï¼Œè¡¨æ˜æ˜¯å¦æ˜¯å‡½æ•°å®šä¹‰çš„blockï¼Œå¦‚æœæ˜¯å°±ä¸å¢åŠ æ–°çš„scopeã€‚é™¤æ­¤ä»¥å¤–ï¼Œé‡åˆ°ä¸€ä¸ª block ä¾¿åŠ ä¸€ä¸ªscope

### å¤–éƒ¨åº“å‡½æ•°

å› ä¸ºæµ‹è¯„éœ€è¦æ ¹æ®è¾“å…¥æ¥è¾“å‡ºç»“æœï¼Œæ‰€ä»¥è¦æ”¯æŒè¾“å…¥è¾“å‡ºçš„å¤–éƒ¨åº“å‡½æ•°ï¼Œä½ éœ€è¦å°†è¿™ä¸ªmapé‡Œé¢çš„functionæ·»åŠ åˆ°çš„ä½ çš„ç¬¦å·è¡¨ä¸­ã€‚

```cpp
map<std::string, ir::Function*>* frontend::get_lib_funcs() {
    static map<std::string, ir::Function*> lib_funcs = {
        {"getint", new Function("getint", Type::Int)},
        {"getch", new Function("getch", Type::Int)},
        {"getfloat", new Function("getfloat", Type::Float)},
        {"getarray",
         new Function("getarray", {Operand("arr", Type::IntPtr)}, Type::Int)},
        {"getfarray",
         new Function(
             "getfarray", {Operand("arr", Type::FloatPtr)}, Type::Int)},
        {"putint",
         new Function("putint", {Operand("i", Type::Int)}, Type::null)},
        {"putch", new Function("putch", {Operand("i", Type::Int)}, Type::null)},
        {"putfloat",
         new Function("putfloat", {Operand("f", Type::Float)}, Type::null)},
        {"putarray",
         new Function("putarray",
                      {Operand("n", Type::Int), Operand("arr", Type::IntPtr)},
                      Type::null)},
        {"putfarray",
         new Function("putfarray",
                      {Operand("n", Type::Int), Operand("arr", Type::FloatPtr)},
                      Type::null)},
    };
    return &lib_funcs;
}

frontend::Analyzer::Analyzer() : tmp_cnt{0}, symbol_table() {
    symbol_table.add_scope();
    ir::Function* global_func = new ir::Function("global", ir::Type::null);
    symbol_table.functions.insert({"global", global_func});
    auto lib_funcs = *get_lib_funcs();
    for (const auto& pair : lib_funcs) {
        symbol_table.functions.insert(pair);
    }
}
```

### Globalå‡½æ•°

å‚è€ƒæŒ‡å¯¼ä¹¦ã€‚è¯·æ³¨æ„æºç¨‹åºä¸­å¹¶æ²¡æœ‰ä¸€ä¸ªå«åš `global`çš„å‡½æ•°ï¼Œæ˜¯å› ä¸ºéœ€è¦å¯¹å…¨å±€å˜é‡è¿›è¡Œåˆå§‹åŒ–ï¼Œæ‰€ä»¥é‡‡ç”¨äº†è¿™æ ·ä¸€ä¸ªç‰¹æ®Šçš„åšæ³•ã€‚

### è°ƒç”¨å¤„ç†

IRç”Ÿæˆéœ€æ¶‰åŠå¯¹å…¨å±€å˜é‡ã€å…¨å±€å¸¸é‡çš„å¤„ç†ã€‚ä¸€ç§å¯è¡Œçš„æ–¹æ³•æ˜¯å°†globalä½œä¸ºä¸€ä¸ª function è¿›è¡Œå¤„ç†ï¼Œé™¤å»å…¶ä¸­å˜é‡ã€å¸¸é‡å®šä¹‰å£°æ˜çš„ IR å¤–ï¼Œä»éœ€ç”Ÿæˆä¸€æ¡ `return null` çš„ IRã€‚å¹¶åœ¨ `main` å‡½æ•°ä¸­é¦–å…ˆç”Ÿæˆå¯¹ `global` çš„è°ƒç”¨IRã€‚