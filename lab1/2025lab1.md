# å®éªŒä¸€(2025)

æœ¬æ–‡æ¡£ä¸ºå®éªŒæŒ‡å¯¼ä¹¦çš„è¡¥å……è¯´æ˜ï¼Œè¯·åŒå­¦ä»¬ä¼˜å…ˆä»”ç»†é˜…è¯»å®éªŒæŒ‡å¯¼ä¹¦

![image-20250408155752469](./assets/image-20250408155752469.png)

![image-20250408155809520](./assets/image-20250408155809520.png)

å®éªŒä¸€å¤§è‡´åˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼Œè¯æ³•åˆ†æï¼šå…ˆå°†æ–‡æœ¬è§£ææˆè¯æ³•å•å…ƒåºåˆ—ï¼Œè¯­æ³•åˆ†æï¼šå†å°†è¯æ³•å•å…ƒåºåˆ—è§£ææˆæŠ½è±¡è¯­æ³•æ ‘ã€‚

## æ•°æ®ç»“æ„ä¸ç®—æ³•

### è¯æ³•åˆ†æç›¸å…³æ•°æ®ç»“æ„

#### Token(è¯æ³•å•å…ƒ)

![image-20250408160025994](./assets/image-20250408160025994.png)

```C++
    // enumerate for Token type
    enum class TokenType
    {
        IDENFR,     // identifier
        INTLTR,     // int literal
        FLOATLTR,   // float literal
        CONSTTK,    // const
        VOIDTK,     // void
        INTTK,      // int
        FLOATTK,    // float
        IFTK,       // if
        ELSETK,     // else
        WHILETK,    // while
        CONTINUETK, // continue
        BREAKTK,    // break
        RETURNTK,   // return
        PLUS,       // +
        MINU,       // -
        MULT,       // *
        DIV,        // /
        MOD,        // %
        LSS,        // <
        GTR,        // >
        COLON,      // :
        ASSIGN,     // =
        SEMICN,     // ;
        COMMA,      // ,
        LPARENT,    // (
        RPARENT,    // )
        LBRACK,     // [
        RBRACK,     // ]
        LBRACE,     // {
        RBRACE,     // }
        NOT,        // !
        LEQ,        // <=
        GEQ,        // >=
        EQL,        // ==
        NEQ,        // !=
        AND,        // &&
        OR,         // ||
    };
    std::string toString(TokenType);

    struct Token
    {
        TokenType type;
        std::string value;
    };
```

`type`è¯æ³•å•å…ƒçš„ç±»å‹

`value`è¯æ³•å•å…ƒçš„å€¼

#### DFA(ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº)

![image-20250408160150910](./assets/image-20250408160150910.png)

```C++
struct DFA
    {
        /**
         * @brief constructor, set the init state to State::Empty
         */
        DFA();

        /**
         * @brief destructor
         */
        ~DFA();

        // the meaning of copy and assignment for a DFA is not clear, so we do not allow them
        DFA(const DFA &) = delete;            // copy constructor
        DFA &operator=(const DFA &) = delete; // assignment

        /**
         * @brief take a char as input, change state to next state, and output a Token if necessary
         * @param[in] input: the input character
         * @param[out] buf: the output Token buffer
         * @return  return true if a Token is produced, the buf is valid then
         */
        bool next(char input, Token &buf);

        /**
         * @brief reset the DFA state to begin
         */
        void reset();

    private:
        State cur_state;     // record current state of the DFA
        std::string cur_str; // record input characters
    };
```

`next()`å½“DFA.cur_stræ»¡è¶³è¯æ³•å•å…ƒåºåˆ—çš„åŒ¹é…è§„åˆ™æ—¶ï¼Œè¿”å›true,è®¾ç½®buf, å¦åˆ™ä¸ºfalse

`reset()`é‡ç½®çŠ¶æ€æœº

#### Scanner(æ‰«æå™¨)

![image-20250408160306434](./assets/image-20250408160306434.png)

```C++
struct Scanner
    {
        /**
         * @brief constructor
         * @param[in] filename: the input file
         */
        Scanner(std::string filename);

        /**
         * @brief destructor, close the file
         */
        ~Scanner();

        // rejcet copy and assignment
        Scanner(const Scanner &) = delete;
        Scanner &operator=(const Scanner &) = delete;

        /**
         * @brief run the scanner, analysis the input file and result a token stream
         * @return std::vector<Token>: the result token stream
         */
        std::vector<Token> run();

    private:
        std::ifstream fin; // the input file
    };
```

`fin`æ˜¯Cè¯­è¨€ç¨‹åºçš„æ–‡ä»¶è¾“å…¥æµ

`run()`æ‰§è¡Œåè¿”å›è¯æ³•å•å…ƒåºåˆ—`std::vector<Token>`

### è¯æ³•åˆ†æç›¸å…³ç®—æ³•

é¦–å…ˆæ¥ä»‹ç»è¯æ³•åˆ†æä¸­æœ€é‡è¦çš„ç»„æˆéƒ¨åˆ†DFA

![lab1dfa.drawio](./assets/lab1dfa.drawio.svg)

DFAç±»ä¸­æœ€é‡è¦å‡½æ•°æ˜¯DFA::next(char input, Token &buf)å‡½æ•°

è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯ï¼š

1. å½“DFA.cur_stræ»¡è¶³è¯æ³•å•å…ƒåºåˆ—çš„åŒ¹é…è§„åˆ™æ—¶ï¼Œè¿”å›trueï¼Œä¾›scannerç±»å¤„ç†;

2. å½“nextå‡½æ•°è¿”å›trueæ—¶ï¼Œæ ¹æ®cur_strè®¾ç½®Token&bufçš„å‚æ•°ï¼Œscannerç±»ä¼šå°†bufæ·»åŠ è¿›std::vector\<frontend::Token\> tk_stream;ä¸­

ä¸Šå›¾æ˜¯ä¸€ä¸ªæˆ‘å½“æ—¶åšå®éªŒå†™çš„ä¸€ä¸ªç®€å•çš„çŠ¶æ€æœºå®ä¾‹ã€‚

æ¯”å¦‚å¯¹äºä¸‹é¢è¿™æ®µæ–‡æœ¬

### ç¤ºä¾‹ä»£ç 

```C
float a =.2;
int b = 0x2;
int main(){
    if(b==2){
        a = 0.1;
    }
}
```

æœ‰å¦‚ä¸‹å¤„ç†æµç¨‹

| input                                     | cur_str | cur_state    | return         |
| ----------------------------------------- | ------- | ------------ | -------------- |
| åˆå§‹                                      | none    | empty        | none           |
| f                                         | f       | ident        | false          |
| l                                         | fl      | ident        | false          |
| o                                         | flo     | ident        | false          |
| a                                         | floa    | ident        | false          |
| t                                         | float   | ident        | false          |
| ç©ºæ ¼                                      | ç©ºæ ¼    | empty        | true å¤„ç†float |
| a                                         | a       | ident        | false          |
| ç©ºæ ¼                                      | ç©ºæ ¼    | empty        | true å¤„ç†a     |
| =                                         | =       | op           | false          |
| .                                         | .       | floatliteral | true å¤„ç†=     |
| 2                                         | .2      | floatliteral | false          |
| ;                                         | ;       | op           | true å¤„ç†.2    |
| int b = 0x2;<br/>int main(){<br/>    if(b | ......  | ......       | ......         |
| =                                         | =       | op           | true å¤„ç†b     |
| 1                                         | ==      | op           |                |
| 2                                         | 2       | intliteral   | true å¤„ç†==    |
| ){<br/>        a = 0.1;<br/>    }<br/>}   | ......  | ......       | ......         |
| ç©ºæ ¼(æœ€åä¸€æ¬¡å°†cur_stræƒ…ç©º)               | ç©ºæ ¼    | empty        | true å¤„ç†}     |

æ‰€ä»¥å¾—åˆ°çš„è¾“å‡ºç»“æœä¸º

| token.value | token.type |
| ----------- | ---------- |
| float       | FLOATTK    |
| a           | IDENT      |
| =           | ASSIGN     |
| .2          | FLOATLTR   |
| ;           | SEMICN     |
| int         | INTTK      |
| b           | IDENT      |
| =           | ASSIGN     |
| 0x2         | INTLTR     |
| int         | INTTK      |
| main        | IDENT      |
| (           | LPARENT    |
| )           | RPARENT    |
| {           | LBRACE     |
| if          | RBRACK     |
| (           | LPARENT    |
| b           | IDENT      |
| ==          | EQL        |
| 2           | INTLTR     |
| )           | RPARENT    |
| {           | LBRACE     |
| a           | IDENT      |
| =           | ASSIGN     |
| 0.1         | FLOATLTR   |
| ;           | SEMICN     |
| }           | RBRACE     |
| }           | RBRACE     |

#### ğŸ§ è¡¥å……è¯´æ˜

1.è¿™é‡Œæ²¡æœ‰è€ƒè™‘æ³¨é‡Šçš„æƒ…å†µï¼Œå¦‚æœå‡ºç°`//æ³¨é‡Š`å’Œ`/*å¤šè¡Œæ³¨é‡Š*/`çš„æƒ…å†µä¸‹æ€ä¹ˆåŠï¼Ÿ

2.æœ‰é™è‡ªåŠ¨æœºä¹Ÿæ˜¯æ­£åˆ™è¡¨è¾¾å¼ç®—æ³•çš„æ ¸å¿ƒå®ç°ï¼Œè¿™é‡Œçš„ç¨‹åºæ˜¯å¦èƒ½ä½¿ç”¨[æ­£åˆ™è¡¨è¾¾å¼](æ­£åˆ™è¡¨è¾¾å¼.md)æ¥é‡æ„ï¼Ÿ

### è¯­æ³•åˆ†æç›¸å…³æ•°æ®ç»“æ„

#### AST(æŠ½è±¡è¯­æ³•æ ‘)

```c++
enum class NodeType {
    TERMINAL,  // terminal lexical unit
    COMPUINT,
    DECL,
    FUNCDEF,
    CONSTDECL,
    BTYPE,
    CONSTDEF,
    CONSTINITVAL,
    VARDECL,
    VARDEF,
    INITVAL,
    FUNCTYPE,
    FUNCFPARAM,
    FUNCFPARAMS,
    BLOCK,
    BLOCKITEM,
    STMT,
    EXP,
    COND,
    LVAL,
    NUMBER,
    PRIMARYEXP,
    UNARYEXP,
    UNARYOP,
    FUNCRPARAMS,
    MULEXP,
    ADDEXP,
    RELEXP,
    EQEXP,
    LANDEXP,
    LOREXP,
    CONSTEXP,
};
std::string toString(NodeType);

struct Varient
{
    Type t;
    Operand v_int;
    Operand v_float;
};

// tree node basic class
struct AstNode
{
    NodeType type;              // the node type
    AstNode* parent;            // the parent node
    vector<AstNode*> children;  // children of node

    /**
     * @brief constructor
     */
    AstNode(NodeType t, AstNode* p = nullptr);

    /**
     * @brief destructor
     */
    virtual ~AstNode();

    /**
     * @brief Get the json output object
     * @param root: a Json::Value buffer, should be initialized before calling
     * this function
     */
    void get_json_output(Json::Value& root) const;

    // rejcet copy and assignment
    AstNode(const AstNode&)            = delete;
    AstNode& operator=(const AstNode&) = delete;
};
```

`type`æŠ½è±¡è¯­æ³•æ ‘èŠ‚ç‚¹ç±»å‹

`parent`çˆ¶æ¯èŠ‚ç‚¹

`children`å­èŠ‚ç‚¹

`get_json_output`è·å–jsonå½¢å¼çš„æŠ½è±¡è¯­æ³•æ ‘è¾“å‡º

#### Parser(è¯­æ³•åˆ†æå™¨)

```C++
struct Parser
{
    uint32_t                  index;  // current token index
    const std::vector<Token>& token_stream;

    /**
     * @brief constructor
     * @param tokens: the input token_stream
     */
    Parser(const std::vector<Token>& tokens);

    /**
     * @brief destructor
     */
    ~Parser();

    /**
     * @brief creat the abstract syntax tree
     * @return the root of abstract syntax tree
     */
    CompUnit* get_abstract_syntax_tree();
    /**
     * @brief for debug, should be called in the beginning of recursive descent
     * functions
     * @param node: current parsing node
     */
    void log(AstNode* node);

    bool parseTerm(AstNode* root, TokenType expect);
    bool parseCompUnit(AstNode* root);
    bool parseDecl(AstNode* root);
    bool parseFuncDef(AstNode* root);
    bool parseConstDecl(AstNode* root);
    bool parseBType(AstNode* root);
    bool parseConstDef(AstNode* root);
    bool parseConstInitVal(AstNode* root);
    bool parseVarDecl(AstNode* root);
    bool parseVarDef(AstNode* root);
    bool parseInitVal(AstNode* root);
    bool parseFuncType(AstNode* root);
    bool parseFuncFParam(AstNode* root);
    bool parseFuncFParams(AstNode* root);
    bool parseBlock(AstNode* root);
    bool parseBlockItem(AstNode* root);
    bool parseStmt(AstNode* root);
    bool parseExp(AstNode* root);
    bool parseCond(AstNode* root);
    bool parseLVal(AstNode* root);
    bool parseNumber(AstNode* root);
    bool parsePrimaryExp(AstNode* root);
    bool parseUnaryExp(AstNode* root);
    bool parseUnaryOp(AstNode* root);
    bool parseFuncRParams(AstNode* root);
    bool parseMulExp(AstNode* root);
    bool parseAddExp(AstNode* root);
    bool parseRelExp(AstNode* root);
    bool parseEqExp(AstNode* root);
    bool parseLAndExp(AstNode* root);
    bool parseLOrExp(AstNode* root);
    bool parseConstExp(AstNode* root);
};
```

`index`ä¸‹ä¸€ä¸ªè§£æçš„è¯æ³•å•å…ƒ

`token_stream`è¯æ³•å•å…ƒåºåˆ—

`get_abstract_syntax_tree()`æŠ½è±¡è¯­æ³•æ ‘æ¥å£

`bool parseXXX(AstNode* root)`è§£æç‰¹å®šçš„æŠ½è±¡è¯­æ³•æ ‘èŠ‚ç‚¹ï¼Œè§£ææˆåŠŸåˆ™è¿”å›true

### è¯­æ³•åˆ†æç›¸å…³ç®—æ³•

![lab1parser.drawio](./assets/lab1parser.drawio.svg)

![image-20250409091308175](./assets/image-20250409091308175.png)

| äº§ç”Ÿå¼ |
| ---------------------------- |
|CompUnit $\rightarrow$ (Decl \| FuncDef) [CompUnit]|
|Decl $\rightarrow$ ConstDecl \| VarDecl|
|ConstDecl $\rightarrow$ 'const' BType ConstDef { ',' ConstDef } ';'|
|BType $\rightarrow$ 'int' \| 'float'|
|ConstDef $\rightarrow$ Ident { '[' ConstExp ']' } '=' ConstInitVal|
|ConstInitVal $\rightarrow$ ConstExp \| '{' [ ConstInitVal { ',' ConstInitVal } ] '}'|
|VarDecl $\rightarrow$ BType VarDef { ',' VarDef } ';'|
|VarDef $\rightarrow$ Ident { '[' ConstExp ']' } [ '=' InitVal ]|
|InitVal $\rightarrow$ Exp \| '{' [ InitVal { ',' InitVal } ] '}'|
|FuncDef $\rightarrow$ FuncType Ident '(' [FuncFParams] ')' Block|
|FuncType $\rightarrow$ 'void' \| 'int' \| 'float'|
|FuncFParam $\rightarrow$ BType Ident ['[' ']' { '[' Exp ']' }]|
|FuncFParams $\rightarrow$ FuncFParam { ',' FuncFParam }|
|Block $\rightarrow$ '{' { BlockItem } '}'|
|BlockItem $\rightarrow$ Decl \| Stmt|
|Stmt $\rightarrow$ LVal '=' Exp ';' \| Block \| 'if' '(' Cond ')' Stmt [ 'else' Stmt ] \| 'while' '(' Cond ')' Stmt \| 'break' ';' \| 'continue' ';' \| 'return' [Exp] ';' \| [Exp] ';'|
|Exp $\rightarrow$ AddExp|
|Cond $\rightarrow$ LOrExp|
|LVal $\rightarrow$ Ident {'[' Exp ']'}|
|Number $\rightarrow$ IntConst \| floatConst|
|PrimaryExp $\rightarrow$ '(' Exp ')' \| LVal \| Number|
|UnaryExp $\rightarrow$ PrimaryExp \| Ident '(' [FuncRParams] ')' \| UnaryOp UnaryExp|
|UnaryOp $\rightarrow$ '+' \| '-' \| '!'|
|FuncRParams $\rightarrow$ Exp { ',' Exp }|
|MulExp $\rightarrow$ UnaryExp { ('\*' \| '/' \| '%') UnaryExp }|
|AddExp $\rightarrow$ MulExp { ('+' \| '-') MulExp }|
|RelExp $\rightarrow$ AddExp { ('<' \| '>' \| '<=' \| '>=') AddExp }|
|EqExp $\rightarrow$ RelExp { ('==' \| '!=') RelExp }|
|LAndExp $\rightarrow$ EqExp [ '&&' LAndExp ]|
|LOrExp $\rightarrow$ LAndExp [ '\|\|' LOrExp ]|
|ConstExp $\rightarrow$ AddExp|

â—è¦é€šè¿‡å®éªŒä¸€çš„æ£€æµ‹ç¨‹åº**å¿…é¡»**æŒ‰ç…§ä¸Šè¿°äº§ç”Ÿå¼è¿›è¡ŒæŠ½è±¡è¯­æ³•æ ‘æ„å»º

**æœ€ç»ˆæˆ‘ä»¬è¦å®ç°syntax.cppæ–‡ä»¶ä¸‹`get_abstract_syntax_tree()`æŠ½è±¡è¯­æ³•æ ‘æ¥å£ã€‚**



â­è¿™éƒ¨åˆ†çš„ä»£ç ä¸»è¦ç”¨åˆ°äº†å›æº¯å’Œé€’å½’çš„æ€æƒ³

`parseXXX()`å‡½æ•°ä¸»è¦åšäº†å¦‚ä¸‹ä¸¤ä»¶äº‹ï¼š

1. å½“è§£æXXXç±»å‹èŠ‚ç‚¹æˆåŠŸæ—¶ï¼Œè¿”å›true
2. è®¾ç½®indexåœ¨æ­£ç¡®çš„ä½ç½®(è§£ææˆåŠŸæ—¶ä¸ºä¸‹ä¸€ä¸ªè¯æ³•å•å…ƒç´¢å¼•ï¼Œå¤±è´¥æ—¶åˆ™ä¸ºè§£æå‰çš„è¯æ³•å•å…ƒç´¢å¼•)

#### ç¤ºä¾‹1:äº§ç”Ÿå¼$A \rightarrow BC$

```
Function ParseA(ASTNode* root)
Begin
	ä¿å­˜indexæ•°æ®
	b = ParseB(ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹)
	å¦‚æœbä¸ºå‡ï¼Œæ¢å¤indexï¼Œè¿”å›false
	//bä¸ºçœŸ
	c = ParseC(ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹)
	å¦‚æœcä¸ºå‡ï¼Œæ¢å¤indexï¼Œè¿”å›false
    åˆ›å»ºAèŠ‚ç‚¹ï¼Œå°†èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹è®¾ä¸ºrootï¼Œå°†è‡ªå·±åŠ å…¥rootçš„å­èŠ‚ç‚¹
	è¿”å›true
End
```

#### ç¤ºä¾‹2:äº§ç”Ÿå¼$A \rightarrow B|C$

```
Function ParseA(ASTNode* root)
Begin
	ä¿å­˜indexæ•°æ®
	b = ParseB(ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹)
	å¦‚æœbä¸ºçœŸï¼Œåˆ›å»ºAèŠ‚ç‚¹ï¼Œå°†èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹è®¾ä¸ºrootï¼Œå°†è‡ªå·±åŠ å…¥rootçš„å­èŠ‚ç‚¹ï¼Œè¿”å›true
	//bä¸ºå‡
	c = ParseC(ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹)
	å¦‚æœcä¸ºçœŸï¼Œåˆ›å»ºAèŠ‚ç‚¹ï¼Œå°†èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹è®¾ä¸ºrootï¼Œå°†è‡ªå·±åŠ å…¥rootçš„å­èŠ‚ç‚¹ï¼Œè¿”å›true
	æ¢å¤index
	è¿”å›false
End
```

#### ç¤ºä¾‹3:äº§ç”Ÿå¼$A \rightarrow B\ B$ ä¸ºç»ˆç»“ç¬¦

```
Function ParseA(ASTNode* root)
Begin
	ä¿å­˜indexæ•°æ®
	å¦‚æœindexå¯¹åº”è¯æ³•å•å…ƒå’ŒBä¸ä¸€è‡´ï¼Œæ¢å¤indexï¼Œè¿”å›false
	//å°è¯•æˆåŠŸ
	index++
    åˆ›å»ºTermç‚¹ï¼Œå°†èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹è®¾ä¸ºrootï¼Œå°†è‡ªå·±åŠ å…¥rootçš„å­èŠ‚ç‚¹
    
	è¿”å›true
End
```

#### â­ç¤ºä¾‹4:ä¼˜å…ˆçº§é—®é¢˜

å¯¹äºå¦‚ä¸‹ä¸€æ®µç‰¹æ®Šä»£ç 

```
f();
```

å‡è®¾ç›®å‰æˆ‘ä»¬å·²ç»åˆ†æåˆ°äº†UnaryExpèŠ‚ç‚¹ï¼Œå¯¹äºä¸Šæ–‡å®šä¹‰æ–‡æ³•å¦‚ä¸‹

UnaryExp $\rightarrow$ PrimaryExp \| Ident '(' [FuncRParams] ')' \| UnaryOp UnaryExp

è¿™é‡Œåº”è¯¥é‡‡ç”¨ç¬¬äºŒæ¡`Ident '(' [FuncRParams] ')'`äº§ç”Ÿå¼ã€‚ä½†æ˜¯å¦‚æœæŒ‰ç…§å…ˆåé¡ºåºåˆ†æï¼Œæˆ‘ä»¬ä¼šå…ˆå°è¯•åˆ†æ`PrimaryExp`ï¼Œé‚£ä¹ˆå®ƒçš„åˆ†æè·¯å¾„å¦‚ä¸‹ï¼š

`PrimaryExp`$\rightarrow$`Lval`$\rightarrow$`'f'`

åˆ†ææˆåŠŸï¼Œè¿”å›trueï¼Œç„¶å`ParseUnaryExp`ä¹Ÿè¿”å›trueï¼Œæ­¤æ—¶indexæŒ‡å‘çš„æ˜¯`(`ï¼Œç„¶åç¨‹åºé€’å½’åˆ°`ParseMulExp`ï¼Œ`ParseMulExp`å°è¯•åˆ†æ`* / %`å¤±è´¥ï¼Œ......ç›´åˆ°æ‰€æœ‰ç¨‹åºéƒ½å°è¯•è§£æ`(`å¤±è´¥ï¼Œç¨‹åºæŠ¥é”™ã€‚

##### è§£å†³æ–¹å¼ï¼šå°†ç¬¬äºŒæ¡`Ident '(' [FuncRParams] ')'`äº§ç”Ÿå¼æå‰åˆ†æã€‚å…ˆåˆ†æéš¾åˆ†æçš„ï¼Œå†åˆ†æç®€å•çš„ï¼Œé‡‡ç”¨`è´ªå©ªæ¨¡å¼`ã€‚

#### â­ç¤ºä¾‹5:å¦ä¸€ç§æ¥å£

ä¸Šé¢æåˆ°çš„ç¤ºä¾‹æ¥å£æ˜¯

```
bool parseXXXXX(AstNode* root);
```

éœ€è¦å°†çˆ¶èŠ‚ç‚¹ä¼ å…¥ï¼Œä¾›å­èŠ‚ç‚¹ä½¿ç”¨ï¼Œå…¶å®æœ‰å¦ä¸€ç§æ›´åŠ ç®€ä¾¿çš„å®šä¹‰æ¥å£çš„åŠæ³•ã€‚

```
AstNode* parseXXXXX();
```

è¿™é‡Œä¸éœ€è¦ä¼ å…¥çˆ¶èŠ‚ç‚¹ï¼Œè€Œæ˜¯å°†å­èŠ‚ç‚¹è¿”å›ç»™çˆ¶èŠ‚ç‚¹ï¼Œè®©çˆ¶èŠ‚ç‚¹æˆä¸ºæ„å»ºæ ‘çš„è´Ÿè´£äººï¼Œå½“æ„å»ºæˆåŠŸæ—¶è¿”å›å­èŠ‚ç‚¹ï¼Œæ„å»ºå¤±è´¥è¿”å›nullptrã€‚

é‚£ä¹ˆå¯¹äºäº§ç”Ÿå¼$A \rightarrow BC$ï¼Œæœ‰ä¼ªä»£ç 

```
Function ParseA(ASTNode* root)
Begin
	ä¿å­˜indexæ•°æ®
	b = ParseB(ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹)
	å¦‚æœbä¸ºnullptrï¼Œæ¢å¤indexï¼Œè¿”å›false
	//bä¸ºçœŸ
	c = ParseC(ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹)
	å¦‚æœcä¸ºnullptrï¼Œæ¢å¤indexï¼Œè¿”å›false
    åˆ›å»ºa = AèŠ‚ç‚¹ï¼Œå°†b,cåŠ å…¥è‡ªå·±çš„å­èŠ‚ç‚¹
	è¿”å›a
End
```

## Q&A

### 1.è¯æ³•åˆ†æä¸­çš„intliteralæœ‰åè¿›åˆ¶42ã€å…«è¿›åˆ¶052ã€åå…­è¿›åˆ¶0x2a, floatliteralæœ‰0.1ã€1.ã€1.0ç­‰å½¢å¼

