# 早发现早停止

**“早发现早停止”，避免“晚爆炸”**


## 🧠 问题：

> “程序报错了？原来是因为空指针。它什么时候变成空指针的？”

程序在某个地方出错了（如空指针访问），但我们**很晚才看到**症状，如何在问题**刚出现时就发现它**？

```cpp
void f(){
    A* it = g();// 这里g()返回了空指针
    ......
    ......
    it->value = "value";//<- ERROR 
    //溯源难度很大，可能it在多个分支语句中被重新赋值
    ......
}
```

## ✅ 解法：在“潜在的出错点”放 `assert()`！

### 🔍 原因：

- `assert()` 会在程序**第一次出现不合理状态时立即终止**，而不是等到后面访问内存才炸。
- 它能精确地告诉你，“这儿的状态不对”，而不是等到程序跑偏一段时间才提示你“已经晚了”。

------

## 🎯 改进你的代码（使用 `assert()`）

```cpp
void f(){
    A* it = g();
    assert(it != nullptr); // ✅ 提前发现问题，清晰地报出是 g() 出了问题

    // 如果没有 assert，这行才崩 → 已经晚了
    it->value = "value";
}
```

### 💥 如果 g() 返回了空指针：

- 没有 assert：程序在 `it->value` 时崩溃，call stack 可能复杂、难找源头。
- 有了 assert：程序会在调用 g() 后立刻报错，告诉你 “g() 返回了空指针”。

------

## ✅ 总结：使用 `assert()` 提前暴露错误的 3 个理由

| 原因                  | 说明                                |
| --------------------- | ----------------------------------- |
| **1. 快速定位问题**   | 错误在第一时间暴露，而不是延迟触发  |
| **2. 提高调试效率**   | 可以明确告诉你“哪一个假设不成立了”  |
| **3. 文档化你的假设** | assert 表达了“我假设它不为空”的意图 |

------

## 🧠 最佳实践建议

| 情况                         | 建议做法                                   |
| ---------------------------- | ------------------------------------------ |
| 调试期验证逻辑               | ✅ 用 `assert()`                            |
| 对外部资源（文件、用户输入） | ❌ 不用 assert，应该用 `throw` 或返回错误码 |
| 生产代码                     | ✅ 用异常或检查，**assert 可选性保留**      |
